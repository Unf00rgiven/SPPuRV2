<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Multi-tasking on arm: rpi_arm_timer_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Multi-tasking on arm
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structrpi__arm__timer__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rpi_arm_timer_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Section 14.2 of the BCM2835 Peripherals documentation details the register layout for the ARM side timer.  
 <a href="structrpi__arm__timer__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rpi-armtimer_8h_source.html">rpi-armtimer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a49255d7a3e736be73d52972836b74e77"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpi__arm__timer__t.html#a49255d7a3e736be73d52972836b74e77">Load</a></td></tr>
<tr class="memdesc:a49255d7a3e736be73d52972836b74e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timer load register sets the time for the timer to count down.  <a href="#a49255d7a3e736be73d52972836b74e77">More...</a><br /></td></tr>
<tr class="separator:a49255d7a3e736be73d52972836b74e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2596d90872655c8a4b88b3ce491464"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpi__arm__timer__t.html#a3d2596d90872655c8a4b88b3ce491464">Value</a></td></tr>
<tr class="memdesc:a3d2596d90872655c8a4b88b3ce491464"><td class="mdescLeft">&#160;</td><td class="mdescRight">This register holds the current timer value and is counted down when the counter is running.  <a href="#a3d2596d90872655c8a4b88b3ce491464">More...</a><br /></td></tr>
<tr class="separator:a3d2596d90872655c8a4b88b3ce491464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdac050597469dd89cf70b6a7eec301"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpi__arm__timer__t.html#aefdac050597469dd89cf70b6a7eec301">Control</a></td></tr>
<tr class="memdesc:aefdac050597469dd89cf70b6a7eec301"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard SP804 timer control register consist of 8 bits but in the BCM implementation there are more control bits for the extra features.  <a href="#aefdac050597469dd89cf70b6a7eec301">More...</a><br /></td></tr>
<tr class="separator:aefdac050597469dd89cf70b6a7eec301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae3715a99d9fea870f0faeb7f9249c6"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpi__arm__timer__t.html#a8ae3715a99d9fea870f0faeb7f9249c6">IRQClear</a></td></tr>
<tr class="memdesc:a8ae3715a99d9fea870f0faeb7f9249c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timer IRQ clear register is write only.  <a href="#a8ae3715a99d9fea870f0faeb7f9249c6">More...</a><br /></td></tr>
<tr class="separator:a8ae3715a99d9fea870f0faeb7f9249c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02265535d091b3eaa138c5f3168d7cf"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpi__arm__timer__t.html#aa02265535d091b3eaa138c5f3168d7cf">RAWIRQ</a></td></tr>
<tr class="memdesc:aa02265535d091b3eaa138c5f3168d7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw IRQ register is a read-only register.  <a href="#aa02265535d091b3eaa138c5f3168d7cf">More...</a><br /></td></tr>
<tr class="separator:aa02265535d091b3eaa138c5f3168d7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d71854538e3af79ccb1279d73ce0a7"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpi__arm__timer__t.html#ab1d71854538e3af79ccb1279d73ce0a7">MaskedIRQ</a></td></tr>
<tr class="memdesc:ab1d71854538e3af79ccb1279d73ce0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The masked IRQ register is a read-only register.  <a href="#ab1d71854538e3af79ccb1279d73ce0a7">More...</a><br /></td></tr>
<tr class="separator:ab1d71854538e3af79ccb1279d73ce0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975f9483670546e152c4f8b4e21298bb"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpi__arm__timer__t.html#a975f9483670546e152c4f8b4e21298bb">Reload</a></td></tr>
<tr class="memdesc:a975f9483670546e152c4f8b4e21298bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This register is a copy of the timer load register.  <a href="#a975f9483670546e152c4f8b4e21298bb">More...</a><br /></td></tr>
<tr class="separator:a975f9483670546e152c4f8b4e21298bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ecc5ca9b7f702213e703b3c3885f20"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpi__arm__timer__t.html#ad1ecc5ca9b7f702213e703b3c3885f20">PreDivider</a></td></tr>
<tr class="memdesc:ad1ecc5ca9b7f702213e703b3c3885f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Pre-divider register is not present in the SP804.  <a href="#ad1ecc5ca9b7f702213e703b3c3885f20">More...</a><br /></td></tr>
<tr class="separator:ad1ecc5ca9b7f702213e703b3c3885f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18611a23c97e303741614f4600e63d25"><td class="memItemLeft" align="right" valign="top">volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpi__arm__timer__t.html#a18611a23c97e303741614f4600e63d25">FreeRunningCounter</a></td></tr>
<tr class="memdesc:a18611a23c97e303741614f4600e63d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The free running counter is not present in the SP804.  <a href="#a18611a23c97e303741614f4600e63d25">More...</a><br /></td></tr>
<tr class="separator:a18611a23c97e303741614f4600e63d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Section 14.2 of the BCM2835 Peripherals documentation details the register layout for the ARM side timer. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="aefdac050597469dd89cf70b6a7eec301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdac050597469dd89cf70b6a7eec301">&#9670;&nbsp;</a></span>Control</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t rpi_arm_timer_t::Control</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The standard SP804 timer control register consist of 8 bits but in the BCM implementation there are more control bits for the extra features. </p>
<p>Control bits 0-7 are identical to the SP804 bits, albeit some functionality of the SP804 is not implemented. All new control bits start from bit 8 upwards. </p>

</div>
</div>
<a id="a18611a23c97e303741614f4600e63d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18611a23c97e303741614f4600e63d25">&#9670;&nbsp;</a></span>FreeRunningCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t rpi_arm_timer_t::FreeRunningCounter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The free running counter is not present in the SP804. </p>
<p>The free running counter is a 32 bits wide read only register. The register is enabled by setting bit 9 of the Timer control register. The free running counter is incremented immediately after it is enabled. The timer can not be reset but when enabled, will always increment and roll-over.</p>
<p>The free running counter is also running from the APB clock and has its own clock pre-divider controlled by bits 16-23 of the timer control register.</p>
<p>This register will be halted too if bit 8 of the control register is set and the ARM is in Debug Halt mode. </p>

</div>
</div>
<a id="a8ae3715a99d9fea870f0faeb7f9249c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae3715a99d9fea870f0faeb7f9249c6">&#9670;&nbsp;</a></span>IRQClear</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t rpi_arm_timer_t::IRQClear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The timer IRQ clear register is write only. </p>
<p>When writing this register the interrupt-pending bit is cleared. When reading this register it returns 0x544D5241 which is the ASCII reversed value for "ARMT". </p>

</div>
</div>
<a id="a49255d7a3e736be73d52972836b74e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49255d7a3e736be73d52972836b74e77">&#9670;&nbsp;</a></span>Load</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t rpi_arm_timer_t::Load</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The timer load register sets the time for the timer to count down. </p>
<p>This value is loaded into the timer value register after the load register has been written or if the timer-value register has counted down to 0. </p>

</div>
</div>
<a id="ab1d71854538e3af79ccb1279d73ce0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d71854538e3af79ccb1279d73ce0a7">&#9670;&nbsp;</a></span>MaskedIRQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t rpi_arm_timer_t::MaskedIRQ</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The masked IRQ register is a read-only register. </p>
<p>It shows the status of the interrupt signal. It is simply a logical AND of the interrupt pending bit and the interrupt enable bit. 0 : Interrupt line not asserted. 1 :Interrupt line is asserted, (the interrupt pending and the interrupt enable bit are set.) </p>

</div>
</div>
<a id="ad1ecc5ca9b7f702213e703b3c3885f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ecc5ca9b7f702213e703b3c3885f20">&#9670;&nbsp;</a></span>PreDivider</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t rpi_arm_timer_t::PreDivider</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Pre-divider register is not present in the SP804. </p>
<p>The pre-divider register is 10 bits wide and can be written or read from. This register has been added as the SP804 expects a 1MHz clock which we do not have. Instead the pre-divider takes the APB clock and divides it down according to:</p>
<p>timer_clock = apb_clock/(pre_divider+1)</p>
<p>The reset value of this register is 0x7D so gives a divide by 126. </p>

</div>
</div>
<a id="aa02265535d091b3eaa138c5f3168d7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02265535d091b3eaa138c5f3168d7cf">&#9670;&nbsp;</a></span>RAWIRQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t rpi_arm_timer_t::RAWIRQ</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The raw IRQ register is a read-only register. </p>
<p>It shows the status of the interrupt pending bit. 0 : The interrupt pending bits is clear. 1 : The interrupt pending bit is set.</p>
<p>The interrupt pending bits is set each time the value register is counted down to zero. The interrupt pending bit can not by itself generates interrupts. Interrupts can only be generated if the interrupt enable bit is set. </p>

</div>
</div>
<a id="a975f9483670546e152c4f8b4e21298bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975f9483670546e152c4f8b4e21298bb">&#9670;&nbsp;</a></span>Reload</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t rpi_arm_timer_t::Reload</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This register is a copy of the timer load register. </p>
<p>The difference is that a write to this register does not trigger an immediate reload of the timer value register. Instead the timer load register value is only accessed if the value register has finished counting down to zero. </p>

</div>
</div>
<a id="a3d2596d90872655c8a4b88b3ce491464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2596d90872655c8a4b88b3ce491464">&#9670;&nbsp;</a></span>Value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t rpi_arm_timer_t::Value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This register holds the current timer value and is counted down when the counter is running. </p>
<p>It is counted down each timer clock until the value 0 is reached. Then the value register is re-loaded from the timer load register and the interrupt pending bit is set. The timer count down speed is set by the timer pre-divide register. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="rpi-armtimer_8h_source.html">rpi-armtimer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
